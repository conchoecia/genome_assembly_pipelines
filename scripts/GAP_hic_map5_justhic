"""
This snakefile maps all the HiC reads to a final genome assembly
  - It also makes a pretextmap file for quickly looking at the hic-maps
  - It also calculates the obs/exp matrix, and the pearson exp matrix of that
  - It maps long reads to the assembly then makes a depth histogram that can be
     viewed in HiGlass

font is small here: https://patorjk.com/software/taag
"""

from Bio import SeqIO
import gzip
import os
import sys
minchromsize = 1000000
configfile: "config.yaml"
config["tool"] = "GAP_hic_map5"
qvals = [0,20]

for x in config["assemblies"]:
    if "_" in x:
        raise IOError("You must not have any special characters in the assembly names: {}. Just use [A-Za-z0-9]+".format(x))

filepath = os.path.dirname(os.path.realpath(workflow.snakefile))
kmer_position_path=os.path.join(filepath, "../bin/kmer_positions.py")
picard_path=os.path.join(filepath, "../bin/picard.jar")
chromappath = os.path.join(filepath, "../bin/chromap/chromap")
bedsort_path=os.path.join(filepath, "../bin/bedSort")
bed2bw_path=os.path.join(filepath,  "../bin/bedGraphToBigWig")

def rc(seq):
    """
    reverse complement the sequence
    """
    this_complement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'}
    return "".join(this_complement.get(base, base) for base in reversed(seq))

def flatten(list_of_lists):
    if len(list_of_lists) == 0:
        return list_of_lists
    if isinstance(list_of_lists[0], list):
        return flatten(list_of_lists[0]) + flatten(list_of_lists[1:])
    return list_of_lists[:1] + flatten(list_of_lists[1:])

def nx(seq, n):
    """
    concats the sequence n times
    """
    return "".join([seq]*n)

if "minimap2arg" not in config:
    config["minimap2arg"] = "map-hifi"

def get_chromosome_sizes(assembly_file, minsize):
    """
    returns a set of chromosomes to keep
    """
    chroms = []
    with open(assembly_file) as handle:
        for record in SeqIO.parse(handle, "fasta"):
            if len(record.seq) >= minsize:
                chroms.append(record.id)
    return chroms

wildcard_constraints:
    datatype="[A-Za-z0-9]+",
    kmer="[A-Za-z0-9]+",
    nom="[A-Za-z0-9.]+",
    telo="[A-Za-z0-9]+",
    binsize="[0-9]+",
    qval="[0-9]+",
    telodir="[fr]"

rule all:
    input:
        # Juicebox Assembly Tools part
        expand(config["tool"] + "/output/{nom}/{nom}.assembly",
               nom = config["assemblies"]),
        expand(config["tool"] + "/output/{nom}/{nom}_allLibs_q_{qval}.hic",
               nom = config["assemblies"], qval = qvals),

# make softlinks of the input files
# files end up here:
#   assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
filepath = os.path.dirname(os.path.realpath(workflow.snakefile))
softlinks_rule_path=os.path.join(filepath, "snakemake_includes/assembly_softlinks")
include: softlinks_rule_path

rule chrom_size:
    """
    make a file with the chromosome sizes
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta"
    output:
        cs = config["tool"] + "/output/{nom}/{nom}_chromsize.txt"
    threads: 1
    shell:
        """
        bioawk -cfastx '{{printf("%s\\t%d\\n", $name, length($seq))}}' {input.assem} > {output.cs}
        """

#      _ ___   _ _____     _    _       __ _ _
#   _ | | _ ) /_\_   _|   | |_ (_)__   / _(_) |___ ___
#  | || | _ \/ _ \| |    _| ' \| / _| |  _| | / -_|_-<
#   \__/|___/_/ \_\_|   (_)_||_|_\__| |_| |_|_\___/__/
#
rule compile_chromap:
    """
    compile chromap if it does not yet exist
    """
    output:
        chromap = os.path.join(filepath, "../bin/chromap/chromap")
    params:
        mvdir = os.path.join(filepath, "../bin/")
    threads: 1
    shell:
        """
        git clone https://github.com/haowenz/chromap.git
        cd chromap
        make
        cd ..
        mv chromap/ {params.mvdir}
        """

rule index_ref:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        chromap = os.path.join(filepath, "../bin/chromap/chromap")
    output:
        index = temp(config["tool"] + "/input/assembly/{nom}_input.fasta.index")
    shell:
        """
        {input.chromap} -i -r {input.assem} -o {output.index}
        """

rule generate_assembly_for_hic_gen:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        awkscript= os.path.abspath(os.path.join( filepath, "../bin/generate-assembly-file-from-fasta.awk"))
    output:
        assembly = config["tool"] + "/input/assembly/{nom}_input.fasta.assembly"
    threads: 1
    shell:
        """
        awk -f {input.awkscript} {input.assem} > {output.assembly}
        """

rule editable_assembly_file:
    """
    from https://bitbucket.org/bredeson/artisanal/src/master/
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        assemfromfasta= os.path.abspath(os.path.join( filepath, "../bin/assembly-from-fasta.py"))
    output:
        assembly = config["tool"] + "/output/{nom}/{nom}.assembly"
    params:
        outprefix = lambda wildcards: config["tool"] + "/output/{d}/{d}".format(
                     d=wildcards.nom)
    threads: 1
    shell:
        """
        python {input.assemfromfasta} -c {input.assem} {params.outprefix}
        """

rule hic_to_pairs:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        index   = config["tool"] + "/input/assembly/{nom}_input.fasta.index",
        chromap = chromappath,
        left  = flatten([config["libs"][x]["read1"] for x in config["libs"]]),
        right = flatten([config["libs"][x]["read2"] for x in config["libs"]])
    output:
        pairs = config["tool"] + "/output/pairs/{nom}/{nom}_q_{qval}.pairs"
    params:
        left  = " -1 ".join(flatten([config["libs"][x]["read1"] for x in config["libs"]])),
        right = " -2 ".join(flatten([config["libs"][x]["read2"] for x in config["libs"]])),
        qval  = lambda wildcards: wildcards.qval
    threads: workflow.cores - 2
    shell:
        """
        {input.chromap} --preset hic -x {input.index} \
            -r {input.assem} \
            -1 {params.left}  \
            -2 {params.right} \
            -t {threads} \
            -q {params.qval} \
            -o {output.pairs}
        """

rule gzip_pairs:
    input:
        pairs = config["tool"] + "/output/pairs/{nom}/{nom}_q_{qval}.pairs"
    output:
        pairs = config["tool"] + "/output/pairs/{nom}/{nom}_q_{qval}.pairs.gz"
    threads: 1
    shell:
        """
        bgzip -c {input.pairs} > {output.pairs}
        """

rule pairs2hiclongformat:
    """
    from https://github.com/Yujiaxin419/ALLHiC/wiki/Manually-refine-ALLHiC-scaffold-assembly-through-juicebox#hic-files
    3d-dna long spec can be found here: https://github.com/aidenlab/juicer/wiki/Pre#long-format
    """
    input:
        pairs = config["tool"] + "/output/pairs/{nom}/{nom}_q_{qval}.pairs"
    output:
        longp = config["tool"] + "/output/pairs/{nom}/{nom}_q_{qval}.long"
    threads: 1
    shell:
        """
        grep -v '#' {input.pairs} | \
        awk '{{if($6!="+") $6=16; else $6=0; if($7!="+") $7=16; else $7=0}} \
            $2<=$4{{print $6, $2, $3, 0, $7, $4, $5, 1, "1 - - 1  - - -" }} \
            $4<$2{{print $7, $4, $5, 0, $6, $2, $3, 1, "1 - - 1  - - -" }}' > {output.longp}
        """

rule get3ddna:
    """
    from https://github.com/Yujiaxin419/ALLHiC/wiki/Manually-refine-ALLHiC-scaffold-assembly-through-juicebox#hic-files
    """
    output:
        hicvis = os.path.join(filepath, "../bin/3d-dna/visualize/run-assembly-visualizer.sh")
    params:
        mvdir = os.path.join(filepath, "../bin/"),
        rmdir = os.path.join(filepath, "../bin/3d-dna"),
    threads: 1
    shell:
        """
        rm -rf 3d-dna
        rm -rf {params.rmdir}
        git clone https://github.com/aidenlab/3d-dna.git
        mv 3d-dna/ {params.mvdir}
        """

rule JBAT_pairs_to_hic:
    """
    Use 3D DNA to make an editable hic file

    This is done in a for loop to avoid race conditions.
    """
    input:
        hicvis = os.path.join(filepath, "../bin/3d-dna/visualize/run-assembly-visualizer.sh"),
        longp = expand(config["tool"] + "/output/pairs/{{nom}}/{{nom}}_q_{qval}.long",
                       qval = qvals),
        assembly = config["tool"] + "/input/assembly/{nom}_input.fasta.assembly"
    output:
        hicmap = expand(config["tool"] + "/output/{{nom}}/{{nom}}_allLibs_q_{qval}.hic",
                        qval = qvals)
    params:
        outprefix  = lambda wildcards: "{}_input.fasta.hic".format(wildcards.nom),
        longprefix = config["tool"] + "/output/pairs/{nom}/{nom}_q_",
        longsuffix = ".long",
        mvprefix  = config["tool"] + "/output/{nom}/{nom}_allLibs_q_",
        mvsuffix  = ".hic",
        qvalsp = " ".join([str(x) for x in qvals])
    threads: 1
    shell:
        """
        for QVAL in {params.qvalsp}; do
           bash {input.hicvis} -p false {input.assembly} {params.longprefix}${{QVAL}}{params.longsuffix} || true
           mv {params.outprefix} {params.mvprefix}${{QVAL}}{params.mvsuffix}
        done
        """
