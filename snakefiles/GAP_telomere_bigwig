"""
This snakefile makes a bigwig file of the telomere sequences in both orientations.

The user provides the sequence in 5'->3' direction.
So the "beginning" of the scaffold should show the reverse complement of the telomere sequence,
 while the "end" of the scaffold should show the telomere sequence in the 5'->3' direction.

"""

from Bio import SeqIO
import gzip
import os
import sys
minchromsize = 1000000
configfile: "config.yaml"
config["tool"] = "GAP_telomere_bigwig"

for x in config["assemblies"]:
    if "_" in x:
        raise IOError("You must not have any special characters in the assembly names: {}. Just use [A-Za-z0-9]+".format(x))

filepath = os.path.dirname(os.path.realpath(workflow.snakefile))
kmer_position_path=os.path.join(filepath, "../bin/kmer_positions.py")
picard_path=os.path.join(filepath, "../bin/picard.jar")
chromappath = os.path.join(filepath, "../bin/chromap/chromap")
bedsort_path=os.path.join(filepath, "../bin/bedSort")
bed2bw_path=os.path.join(filepath,  "../bin/bedGraphToBigWig")

def rc(seq):
    """
    reverse complement the sequence
    """
    this_complement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'}
    return "".join(this_complement.get(base, base) for base in reversed(seq))

def flatten(list_of_tuples):
    return [item for pair in list_of_tuples for item in pair]

###
###  KMER PARSING SECTION
###
# if kmers not specified in config, add
if "kmers" not in config:
    config["kmers"] = []

# if telomere kmers not specified in the config file, use regular metazoan seq
if "telomere_seqs" not in config:
    config["telomere_seqs"] = ["TTAGGG"]
config["telomere_seqs"] = [x.upper() for x in config["telomere_seqs"]]

# make sure that there are no reverse complements in the telomere_seqs
#  we don't want this because we specifically define the revcomp in the
#  next step
for x in config["telomere_seqs"]:
    if rc(x) in config["telomere_seqs"]:
        raise IOError("Don't include the reverse reverse complement of the telomere sequences")

# set up the telomere strands
config["telomere_strands"] = {seq: (seq, rc(seq)) for seq in config["telomere_seqs"]}
#config["telomere_strands"] = []
#for seq in config["telomere_seqs"]:
#    config["telomere_strands"].append((seq, "f"))
#    config["telomere_strands"].append((rc(seq), "r"))

# now that we're done with the telomere strands, add the rcs to independently look
config["telomere_seqs"] += [rc(x) for x in config["telomere_seqs"]]

# make sure all the kmers are uppercase. If the rc is also present, remove it
keeps = []
for i in range(len(config["telomere_seqs"])):
    thiskmer = config["telomere_seqs"][i].upper()
    thisrc = rc(thiskmer)
    if (thiskmer not in keeps) and (thisrc not in keeps):
        keeps.append(thiskmer)
config["telomere_seqs"] = keeps

wildcard_constraints:
    datatype="[A-Za-z0-9]+",
    kmer="[A-Za-z0-9]+",
    nom="[A-Za-z0-9.]+",
    telo="[A-Za-z0-9]+",
    binsize="[0-9]+",
    qval="[0-9]+"
rule all:
    input:
        # gaps
        expand(config["tool"] + "/output/{nom}/{nom}_gaps.bed",
               nom = config["assemblies"]),
        #expand(config["tool"] + "/output/{nom}/{nom}_gaps.beddb",
        #       nom = config["assemblies"]),
        # Telomere and kmer depth bigwigs
        expand(config["tool"] + "/output/{nom}/{nom}_teloKmer_{telo}.bw",
               telo = flatten(config["telomere_strands"].values()),
               nom = config["assemblies"])
        #expand(config["tool"] + "/output/{nom}/{nom}_kmer_{kmer}.bw",
        #       kmer = config["kmers"], nom = config["assemblies"]),

# make softlinks of the input files
# files end up here:
#   assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
filepath = os.path.dirname(os.path.realpath(workflow.snakefile))
softlinks_rule_path=os.path.join(filepath, "snakemake_includes/assembly_softlinks")
include: softlinks_rule_path

#   ___  _   _              _  _ _  ___ _              ___ _         __  __
#  / _ \| |_| |_  ___ _ _  | || (_)/ __| |__ _ ______ / __| |_ _  _ / _|/ _|
# | (_) |  _| ' \/ -_) '_| | __ | | (_ | / _` (_-<_-< \__ \  _| || |  _|  _|
#  \___/ \__|_||_\___|_|   |_||_|_|\___|_\__,_/__/__/ |___/\__|\_,_|_| |_|

rule chrom_size:
    """
    make a file with the chromosome sizes
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta"
    output:
        cs = config["tool"] + "/output/{nom}/{nom}_chromsize.txt"
    threads: 1
    shell:
        """
        bioawk -cfastx '{{printf("%s\\t%d\\n", $name, length($seq))}}' {input.assem} > {output.cs}
        """


rule genome_bed:
    """
    just a bed file of the whole genome assembly to usebedtools subtract
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta"
    output:
        bed   = config["tool"] + "/output/{nom}/{nom}.bed"
    threads: 1
    shell:
        """
        bioawk -cfastx '{{printf("%s\\t0\\t%d\\n", $name, length($seq))}}' {input.assem} | \
          bedtools sort > {output.bed}
        """

rule gaps_from_assembly:
    input:
        assem  = config["tool"] + "/input/assembly/{nom}_input.fasta",
    output:
        gapbed = config["tool"] + "/output/{nom}/{nom}_gaps.bed"
    threads: 1
    run:
        # this block of code from https://www.biostars.org/p/133742/
        #import the SeqIO module from Biopython
        outhandle = open(output.gapbed, "w")
        with open(input.assem, mode="r") as fasta_handle:
            for record in SeqIO.parse(fasta_handle, "fasta"):
                start_pos=0
                counter=0
                gap=False
                gap_length = 0
                for char in record.seq:
                    if char == 'N':
                        if gap_length == 0:
                            start_pos=counter
                            gap_length = 1
                            gap = True
                        else:
                            gap_length += 1
                    else:
                        if gap:
                            print("{} {} {}".format(
                                record.id,
                                start_pos,
                                start_pos + gap_length),
                                  file = outhandle)
                            gap_length = 0
                            gap = False
                    counter += 1
        outhandle.close()

#rule make_gaps_beddb:
#    """
#    This is really only for highglass, so it can be
#    """
#    input:
#        assem  = config["tool"] + "/input/assembly/{nom}_input.fasta",
#        gapbed = config["tool"] + "/output/{nom}/{nom}_gaps.bed",
#        cs     = config["tool"] + "/output/{nom}/{nom}_chromsize.txt"
#    output:
#        beddb = config["tool"] + "/output/{nom}/{nom}_gaps.beddb"
#    threads: 1
#    shell:
#        """
#        clodius aggregate bedfile \
#          --chromsizes-filename {input.cs} \
#          --delimiter " " {input.gapbed} \
#          --assembly {input.assem} \
#          --output-file {output.beddb}
#        """

# ___________    .__                                         __
# \__    ___/___ |  |   ____   _____   ___________   ____   |  | __ _____   ___________
#   |    |_/ __ \|  |  /  _ \ /     \_/ __ \_  __ \_/ __ \  |  |/ //     \_/ __ \_  __ \
#   |    |\  ___/|  |_(  <_> )  Y Y  \  ___/|  | \/\  ___/  |    <|  Y Y  \  ___/|  | \/
#   |____| \___  >____/\____/|__|_|  /\___  >__|    \___  > |__|_ \__|_|  /\___  >__|
#              \/                  \/     \/            \/       \/     \/     \/

rule telomere_kmer_positions_bigwig:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        kmer_counter = kmer_position_path,
        bed = config["tool"] + "/output/{nom}/{nom}.bed",
        bedsort = bedsort_path,
        bed2bw = bed2bw_path,
        cs = config["tool"] + "/output/{nom}/{nom}_chromsize.txt"
    output:
        temppos   = temp(config["tool"] + "/output/{nom}/TEMP_{nom}_teloKmer_{telo}.nozero.bg"),
        tempzeros = temp(config["tool"] + "/output/{nom}/TEMP_{nom}_teloKmer_{telo}.zero.bg"),
        bg    =     temp(config["tool"] + "/output/{nom}/{nom}_teloKmer_{telo}.bg"),
        depth =     temp(config["tool"] + "/output/{nom}/{nom}_teloKmer_{telo}.s.bg"),
        bw    =          config["tool"] + "/output/{nom}/{nom}_teloKmer_{telo}.bw"
    params:
        k = lambda wildcards: len(wildcards.telo)
    threads: 1
    shell:
        """
        # get the kmer positions
        cat {input.assem} | \
          python {input.kmer_counter} {wildcards.telo} | \
          bedtools merge | \
          awk '{{ printf("%s\\t%d\\t%d\\t%d\\n", $1, $2, $3, ($3 - $2) / {params.k}) }}' | \
          bedtools sort > {output.temppos}

        # get subtract for the zero positions
        bedtools subtract -a {input.bed} -b {output.temppos} | \
          awk '{{printf("%s\\t0\\n", $0)}}' > {output.tempzeros}

        # now cat and sort
        cat {output.temppos} {output.tempzeros} | \
          sort -k1,1 -k2,2n -k3,3n > {output.bg}

        # now do the steps to make a bigwig
        chmod u+x {input.bedsort}
        chmod u+x {input.bed2bw}
        {input.bedsort} {output.bg} {output.depth}
        {input.bed2bw} {output.depth} {input.cs} {output.bw}
        """

#rule telomere_kmer_bigwig_to_multivec:
#    """
#    This is for HiGlass. Turn this off if you don't need it.
#    make a multivec from multiple bigwig files based on working multivec spec
#      - https://paper.dropbox.com/doc/Multivec-Spec-3IelZjzjXDo7mGy3SkGUF
#
#    This multivec file is from looking at the kmers present in the genome
#
#    #--row-infos-filename {input.rows} \
#    """
#    input:
#        bw_pairs = lambda wildcards: [
#            [
#                config["tool"]}+ "/output/{wildcards.nom}/{wildcards.nom}_teloKmer_{fwd}.bw",
#                config["tool"]}+ "/output/{wildcards.nom}/{wildcards.nom}_teloKmer_{rev}.bw"
#            ]
#            for fwd, rev in config["telomere_strands"]
#        ],
#        cs = config["tool"] + "/output/{nom}/{nom}_chromsize.txt"
#    output:
#        multivec = config["tool"] + "/output/{nom}/{nom}_telomereKmerDepth_{telo}.bw.mv5"
#    threads: 1
#    shell:
#        """
#        clodius convert bigwigs-to-multivec {input.bw_f} {input.bw_r} \
#        --chromsizes-filename {input.cs} \
#        --output-file {output.multivec}
#        """

rule kmer_positions_bigwig:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        kmer_counter = kmer_position_path,
        bed = config["tool"] + "/output/{nom}/{nom}.bed",
        bedsort = bedsort_path,
        bed2bw = bed2bw_path,
        cs = config["tool"] + "/output/{nom}/{nom}_chromsize.txt"
    output:
        temppos   = temp(config["tool"] + "/output/depth/TEMP_{nom}_kmer_{kmer}.nozero.bg"),
        tempzeros = temp(config["tool"] + "/output/depth/TEMP_{nom}_kmer_{kmer}.zero.bg"),
        bg    =      config["tool"] + "/output/depth/{nom}_kmer_{kmer}.bg",
        depth = temp(config["tool"] + "/output/depth/{nom}_kmer_{kmer}.s.bg"),
        bw    =      config["tool"] + "/output/{nom}/{nom}_kmer_{kmer}.bw"
    params:
        tkmers = lambda wildcards: " ".join(config["kmers"][wildcards.kmer]),
        k = lambda wildcards: int(list(set([len(x) for x in config["kmers"][wildcards.kmer]]))[0])
    threads: 1
    shell:
        """
        # get the kmer positions
        cat {input.assem} | \
          python {input.kmer_counter} {params.k} {params.tkmers} | \
          bedtools merge | \
          awk '{{ printf("%s\t%d\t%d\t%d\n", $1, $2, $3, ($3 - $2) / {params.k}) }}' | \
          bedtools sort > {output.temppos}

        # get subtract for the zero positions
        bedtools subtract -a {input.bed} -b {output.temppos} | \
          awk '{{printf("%s\\t0\\n", $0)}}' > {output.tempzeros}

        # now cat and sort
        cat {output.temppos} {output.tempzeros} | \
          sort -k1,1 -k2,2n -k3,3n > {output.bg}

        # now do the steps to make a bigwig
        chmod u+x {input.bedsort}
        chmod u+x {input.bed2bw}
        {input.bedsort} {output.bg} {output.depth}
        {input.bed2bw} {output.depth} {input.cs} {output.bw}
        """

# BG to BW
#   ___  ___   _         _____      __
#  | _ )/ __| | |_ ___  | _ ) \    / /
#  | _ \ (_ | |  _/ _ \ | _ \\ \/\/ /
#  |___/\___|  \__\___/ |___/ \_/\_/
#

rule bedgraph_and_bed2bigwig:
    input:
        depth   = config["tool"] + "/output/depth/{nom}_{datatype}.bg",
        bedsort = bedsort_path,
        bed2bw = bed2bw_path,
        cs = config["tool"] + "/output/{nom}/{nom}_chromsize.txt"
    output:
        depth = temp(config["tool"] + "/output/depth/{nom}_{datatype}.s.bg"),
        bw    = config["tool"] + "/output/{nom}/{nom}_{datatype}.bw"
    threads: 1
    shell:
        """
        chmod u+x {input.bedsort}
        chmod u+x {input.bed2bw}
        {input.bedsort} {input.depth} {output.depth}
        {input.bed2bw} {output.depth} {input.cs} {output.bw}
        """