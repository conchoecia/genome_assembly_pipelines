# Snakefile for dipcall-style assembly evaluation for sample D21
# Assumes:
#   - pat.fa.gz and mat.fa.gz are in this directory
#   - dipcall.kit/ contains minimap2, k8, samtools, htsbox, bedtk, dipcall-aux.js, paftools.js, hs37d5.PAR.bed

# This is derived from a makefile generated by dipcall
#
# ROOT=./dipcall.kit
# N_THREADS=8
# MAPPER=minimap2
# MM2_IDX=/oak/stanford/groups/tttt/users/darrints/data/hs37d5_reference/hs37d5.fa
# MM2_OPT=-xasm5 --cs -t$(N_THREADS)
# REF_FA=/oak/stanford/groups/tttt/users/darrints/data/hs37d5_reference/hs37d5.fa
# 
# all:D21.dip.bed D21.dip.vcf.gz
# 
# D21.hap1.paf.gz:pat.fa.gz
#         $(ROOT)/$(MAPPER) -c --paf-no-hit $(MM2_OPT) $(MM2_IDX) $< 2> $@.log | gzip > $@
# D21.hap2.paf.gz:mat.fa.gz
#         $(ROOT)/$(MAPPER) -c --paf-no-hit $(MM2_OPT) $(MM2_IDX) $< 2> $@.log | gzip > $@
# 
# D21.hap1.sam.gz:pat.fa.gz
#         $(ROOT)/$(MAPPER) -a $(MM2_OPT) $(MM2_IDX) $< 2> $@.log | gzip > $@
# D21.hap2.sam.gz:mat.fa.gz
#         $(ROOT)/$(MAPPER) -a $(MM2_OPT) $(MM2_IDX) $< 2> $@.log | gzip > $@
# 
# D21.hap1.bam:D21.hap1.sam.gz
#         $(ROOT)/k8 $(ROOT)/dipcall-aux.js samflt $< | $(ROOT)/samtools sort -m4G --threads 4 -o $@ -
# D21.hap2.bam:D21.hap2.sam.gz
#         $(ROOT)/k8 $(ROOT)/dipcall-aux.js samflt $< | $(ROOT)/samtools sort -m4G --threads 4 -o $@ -
# 
# D21.pair.vcf.gz:D21.hap1.bam D21.hap2.bam
#         $(ROOT)/htsbox pileup -q5 -evcf $(REF_FA) $^ | $(ROOT)/htsbox bgzip > $@
# D21.dip.vcf.gz:D21.pair.vcf.gz
#         $(ROOT)/k8 $(ROOT)/dipcall-aux.js vcfpair  -p ./dipcall.kit/hs37d5.PAR.bed $< | $(ROOT)/htsbox bgzip > $@
# 
# D21.hap1.var.gz:D21.hap1.paf.gz
#         gzip -dc $< | sort -k6,6 -k8,8n | $(ROOT)/k8 $(ROOT)/paftools.js call - 2> $@.vst | gzip > $@
# D21.hap2.var.gz:D21.hap2.paf.gz
#         gzip -dc $< | sort -k6,6 -k8,8n | $(ROOT)/k8 $(ROOT)/paftools.js call - 2> $@.vst | gzip > $@
# D21.hap1.bed:D21.hap1.var.gz
#         gzip -dc $< | grep ^R | cut -f2- > $@
# D21.hap2.bed:D21.hap2.var.gz
#         gzip -dc $< | grep ^R | cut -f2- > $@
# D21.dip.bed:D21.hap1.bed D21.hap2.bed
#         $(ROOT)/bedtk isec D21.hap1.bed D21.hap2.bed | egrep -v '^(chr)?[XY]' > D21.tmp.bed; $(ROOT)/bedtk isec D21.hap1.bed D21.hap2.bed | $(ROOT)/bedtk isec ./dipcall.kit/hs37d5.PAR.bed >> D21.tmp.bed; $(ROOT)/bedtk sub D21.hap2.bed D21.hap1.bed | egrep '^(chr)?X' | $(ROOT)/bedtk sub - ./dipcall.kit/hs37d5.PAR.bed >> D21.tmp.bed; $(ROOT)/bedtk sub D21.hap1.bed D21.hap2.bed | egrep '^(chr)?Y' >> D21.tmp.bed; $(ROOT)/bedtk sort D21.tmp.bed > $@

shell.executable("/bin/bash")

configfile: "config.yaml"

# Load user-configurable parameters from config file
SAMPLE   = config["sample"]
ROOT     = "dipcall.kit"
REF_FA   = config["ref_fa"]
MM2_IDX  = REF_FA
THREADS  = config["threads"]
MAPPER   = "minimap2"

# These are the minimap2 options you had in the Makefile
MM2_OPTS = "-x asm5 --cs"

PAR_BED  = config["par_bed"]

# Map hap wildcard to input fasta
hap_fa = config["hap_fa"]

config["tool"] = "GAP_phase_dipcall"


rule all:
    input:
        config["tool"] + f"/{SAMPLE}.dip.vcf.gz",
        config["tool"] + f"/{SAMPLE}.dip.bed"


######################################################################
# Step 0: Install dipcall toolkit
######################################################################

rule install_dipcall:
    output:
        directory(ROOT)
    threads: 1
    resources:
        mem_mb = 1000,
        runtime = 30
    shell:
        """
        wget https://github.com/lh3/dipcall/releases/download/v0.3/dipcall-0.3_x64-linux.tar.bz2
        tar -jxf dipcall-0.3_x64-linux.tar.bz2
        rm -f dipcall-0.3_x64-linux.tar.bz2
        """


######################################################################
# Step 1: Map assemblies to reference
######################################################################

# PAF mapping (assembly vs reference)
rule map_paf:
    input:
        lambda wc: hap_fa[wc.hap]
    output:
        config["tool"] + "/{sample}.hap{hap}.paf.gz"
    log:
        config["tool"] + "/{sample}.hap{hap}.paf.gz.log"
    threads: 8
    resources:
        mem_mb = 16000,
        runtime = 2880
    params:
        root   = ROOT,
        mapper = MAPPER,
        ref    = MM2_IDX,
        mm2    = MM2_OPTS
    shell:
        """
        mkdir -p $(dirname {output})
        {params.root}/{params.mapper} -c --paf-no-hit {params.mm2} -t {threads} {params.ref} {input} \
            2> {log} | gzip -c > {output}
        """

# SAM mapping (for BAM + pileup)
rule map_sam:
    input:
        lambda wc: hap_fa[wc.hap]
    output:
        config["tool"] + "/{sample}.hap{hap}.sam.gz"
    log:
        config["tool"] + "/{sample}.hap{hap}.sam.gz.log"
    threads: 8
    resources:
        mem_mb = 16000,
        runtime = 2880
    params:
        root   = ROOT,
        mapper = MAPPER,
        ref    = MM2_IDX,
        mm2    = MM2_OPTS
    shell:
        """
        mkdir -p $(dirname {output})
        {params.root}/{params.mapper} -a {params.mm2} -t {threads} {params.ref} {input} \
            2> {log} | gzip -c > {output}
        """

######################################################################
# Step 2: Process PAF files to variant calls and BED regions
######################################################################

# Call variants from PAF with paftools (per haplotype)
rule hap_var:
    input:
        paf = config["tool"] + "/{sample}.hap{hap}.paf.gz"
    output:
        var = config["tool"] + "/{sample}.hap{hap}.var.gz"
    log:
        config["tool"] + "/{sample}.hap{hap}.var.gz.vst"
    threads: 1
    resources:
        mem_mb = 8000,
        runtime = 180
    params:
        root = ROOT
    shell:
        """
        gzip -dc {input.paf} \
          | sort -k6,6 -k8,8n \
          | {params.root}/k8 {params.root}/paftools.js call - 2> {log} \
          | gzip -c > {output.var}
        """

# Extract R lines to BED (per haplotype)
rule hap_bed:
    input:
        config["tool"] + "/{sample}.hap{hap}.var.gz"
    output:
        config["tool"] + "/{sample}.hap{hap}.bed"
    threads: 1
    resources:
        mem_mb = 4000,
        runtime = 30
    shell:
        """
        gzip -dc {input} | grep '^R' | cut -f2- > {output}
        """

######################################################################
# Step 3: Process SAM files to BAM and variant calls
######################################################################

# Filter SAM and sort to BAM
rule sam_to_bam:
    input:
        sam = config["tool"] + "/{sample}.hap{hap}.sam.gz"
    output:
        bam = config["tool"] + "/{sample}.hap{hap}.bam"
    log:
        config["tool"] + "/{sample}.hap{hap}.bam.log"
    threads: 4
    resources:
        mem_mb = 20000,
        runtime = 360
    params:
        root = ROOT
    shell:
        """
        {params.root}/k8 {params.root}/dipcall-aux.js samflt {input.sam} 2> {log} \
            | {params.root}/samtools sort -m4G --threads 4 -o {output.bam} -
        """

# Joint pileup to pair VCF (hap1 + hap2 as two samples)
rule pair_vcf:
    input:
        hap1 = config["tool"] + f"/{SAMPLE}.hap1.bam",
        hap2 = config["tool"] + f"/{SAMPLE}.hap2.bam"
    output:
        config["tool"] + f"/{SAMPLE}.pair.vcf.gz"
    log:
        config["tool"] + f"/{SAMPLE}.pair.vcf.gz.log"
    threads: 2
    resources:
        mem_mb = 16000,
        runtime = 480
    params:
        root = ROOT,
        ref  = REF_FA
    shell:
        """
        {params.root}/htsbox pileup -q5 -evcf {params.ref} {input.hap1} {input.hap2} 2> {log} \
            | {params.root}/htsbox bgzip > {output}
        """


######################################################################
# Step 4: Generate final outputs
######################################################################

# Convert pair VCF to diploid VCF (handle PAR properly)
rule dip_vcf:
    input:
        config["tool"] + f"/{SAMPLE}.pair.vcf.gz"
    output:
        config["tool"] + f"/{SAMPLE}.dip.vcf.gz"
    log:
        config["tool"] + f"/{SAMPLE}.dip.vcf.gz.log"
    threads: 1
    resources:
        mem_mb = 8000,
        runtime = 120
    params:
        root   = ROOT,
        parbed = PAR_BED
    shell:
        """
        {params.root}/k8 {params.root}/dipcall-aux.js vcfpair -p {params.parbed} {input} 2> {log} \
            | {params.root}/htsbox bgzip > {output}
        """

# Combine hap1/hap2 BEDs into dipcall-style diploid callable BED
rule dip_bed:
    input:
        hap1_bed = config["tool"] + f"/{SAMPLE}.hap1.bed",
        hap2_bed = config["tool"] + f"/{SAMPLE}.hap2.bed"
    output:
        config["tool"] + f"/{SAMPLE}.dip.bed"
    log:
        config["tool"] + f"/{SAMPLE}.dip.bed.log"
    threads: 1
    resources:
        mem_mb = 8000,
        runtime = 60
    params:
        root   = ROOT,
        parbed = PAR_BED,
        tmp    = config["tool"] + f"/{SAMPLE}.tmp.bed"
    shell:
        """
        set -euo pipefail

        # Autosomes: intersection of both haps, excluding X/Y
        {params.root}/bedtk isec {input.hap1_bed} {input.hap2_bed} \
            | egrep -v '^(chr)?[XY]' > {params.tmp}

        # PAR: intersection of both haps, intersected with PAR bed
        {params.root}/bedtk isec {input.hap1_bed} {input.hap2_bed} \
            | {params.root}/bedtk isec {params.parbed} >> {params.tmp}

         Non-PAR X: hap2 minus hap1, minus PAR
        {params.root}/bedtk sub {input.hap2_bed} {input.hap1_bed} \
            | egrep '^(chr)?X' \
            | {params.root}/bedtk sub - {params.parbed} >> {params.tmp}

        # Y: hap1 minus hap2
        {params.root}/bedtk sub {input.hap1_bed} {input.hap2_bed} \
            | egrep '^(chr)?Y' >> {params.tmp}

        {params.root}/bedtk sort {params.tmp} > {output}
        """