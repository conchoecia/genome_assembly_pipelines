# Snakefile for dipcall-style assembly evaluation for sample D21
# Assumes:
#   - pat.fa.gz and mat.fa.gz are in this directory
#   - dipcall.kit/ contains minimap2, k8, samtools, htsbox, bedtk, dipcall-aux.js, paftools.js, hs37d5.PAR.bed

# This is derived from a makefile generated by dipcall
#
# ROOT=./dipcall.kit
# N_THREADS=8
# MAPPER=minimap2
# MM2_IDX=/oak/stanford/groups/tttt/users/darrints/data/hs37d5_reference/hs37d5.fa
# MM2_OPT=-xasm5 --cs -t$(N_THREADS)
# REF_FA=/oak/stanford/groups/tttt/users/darrints/data/hs37d5_reference/hs37d5.fa
#
# all:D21.dip.bed D21.dip.vcf.gz
#
# D21.hap1.paf.gz:pat.fa.gz
#         $(ROOT)/$(MAPPER) -c --paf-no-hit $(MM2_OPT) $(MM2_IDX) $< 2> $@.log | gzip > $@
# D21.hap2.paf.gz:mat.fa.gz
#         $(ROOT)/$(MAPPER) -c --paf-no-hit $(MM2_OPT) $(MM2_IDX) $< 2> $@.log | gzip > $@
#
# D21.hap1.sam.gz:pat.fa.gz
#         $(ROOT)/$(MAPPER) -a $(MM2_OPT) $(MM2_IDX) $< 2> $@.log | gzip > $@
# D21.hap2.sam.gz:mat.fa.gz
#         $(ROOT)/$(MAPPER) -a $(MM2_OPT) $(MM2_IDX) $< 2> $@.log | gzip > $@
#
# D21.hap1.bam:D21.hap1.sam.gz
#         $(ROOT)/k8 $(ROOT)/dipcall-aux.js samflt $< | $(ROOT)/samtools sort -m4G --threads 4 -o $@ -
# D21.hap2.bam:D21.hap2.sam.gz
#         $(ROOT)/k8 $(ROOT)/dipcall-aux.js samflt $< | $(ROOT)/samtools sort -m4G --threads 4 -o $@ -
#
# D21.pair.vcf.gz:D21.hap1.bam D21.hap2.bam
#         $(ROOT)/htsbox pileup -q5 -evcf $(REF_FA) $^ | $(ROOT)/htsbox bgzip > $@
# D21.dip.vcf.gz:D21.pair.vcf.gz
#         $(ROOT)/k8 $(ROOT)/dipcall-aux.js vcfpair  -p ./dipcall.kit/hs37d5.PAR.bed $< | $(ROOT)/htsbox bgzip > $@
#
# D21.hap1.var.gz:D21.hap1.paf.gz
#         gzip -dc $< | sort -k6,6 -k8,8n | $(ROOT)/k8 $(ROOT)/paftools.js call - 2> $@.vst | gzip > $@
# D21.hap2.var.gz:D21.hap2.paf.gz
#         gzip -dc $< | sort -k6,6 -k8,8n | $(ROOT)/k8 $(ROOT)/paftools.js call - 2> $@.vst | gzip > $@
# D21.hap1.bed:D21.hap1.var.gz
#         gzip -dc $< | grep ^R | cut -f2- > $@
# D21.hap2.bed:D21.hap2.var.gz
#         gzip -dc $< | grep ^R | cut -f2- > $@
# D21.dip.bed:D21.hap1.bed D21.hap2.bed
#         $(ROOT)/bedtk isec D21.hap1.bed D21.hap2.bed | egrep -v '^(chr)?[XY]' > D21.tmp.bed; $(ROOT)/bedtk isec D21.hap1.bed D21.hap2.bed | $(ROOT)/bedtk isec ./dipcall.kit/hs37d5.PAR.bed >> D21.tmp.bed; $(ROOT)/bedtk sub D21.hap2.bed D21.hap1.bed | egrep '^(chr)?X' | $(ROOT)/bedtk sub - ./dipcall.kit/hs37d5.PAR.bed >> D21.tmp.bed; $(ROOT)/bedtk sub D21.hap1.bed D21.hap2.bed | egrep '^(chr)?Y' >> D21.tmp.bed; $(ROOT)/bedtk sort D21.tmp.bed > $@

shell.executable("/bin/bash")

configfile: "config.yaml"

# Load user-configurable parameters from config file
SAMPLE   = config["sample"]
ROOT     = "dipcall.kit"
REF_FA   = config["ref_fa"]
MM2_IDX  = REF_FA
THREADS  = config["threads"]
MAPPER   = "minimap2"

# These are the minimap2 options you had in the Makefile
MM2_OPTS = "-x asm5 --cs"

PAR_BED  = config["par_bed"]

# Map hap wildcard to input fasta
hap_fa = config["hap_fa"]

config["tool"] = "GAP_phase_dipcall"


rule all:
    input:
        config["tool"] + f"/{SAMPLE}.dip.vcf.gz",
        config["tool"] + f"/{SAMPLE}.dip.bed"


######################################################################
# Step 0: Install dipcall toolkit
######################################################################

rule install_dipcall:
    output:
        minimap2    = ROOT + "/minimap2",
        k8          = ROOT + "/k8",
        samtools    = ROOT + "/samtools",
        htsbox      = ROOT + "/htsbox",
        bedtk       = ROOT + "/bedtk",
        paftools    = ROOT + "/paftools.js",
        dipcall_aux = ROOT + "/dipcall-aux.js",
        par_bed     = ROOT + "/hs37d5.PAR.bed"
    threads: 1
    resources:
        mem_mb = 1000,
        runtime = 30
    shell:
        """
        wget https://github.com/lh3/dipcall/releases/download/v0.3/dipcall-0.3_x64-linux.tar.bz2
        tar -jxf dipcall-0.3_x64-linux.tar.bz2
        rm -f dipcall-0.3_x64-linux.tar.bz2
        """

######################################################################
# Step 1: Map assemblies to reference
######################################################################

# PAF mapping (assembly vs reference)
rule map_paf:
    input:
        assembly = lambda wc: hap_fa[wc.hap],
        minimap2 = ROOT + "/minimap2",
        ref_fa   = REF_FA
    output:
        config["tool"] + "/{sample}.hap{hap}.paf.gz"
    log:
        config["tool"] + "/{sample}.hap{hap}.paf.gz.log"
    threads: 8
    resources:
        mem_mb = 16000,
        runtime = 2880
    params:
        mm2 = MM2_OPTS
    shell:
        """
        mkdir -p $(dirname {output})
        {input.minimap2} -c --paf-no-hit {params.mm2} -t {threads} {input.ref_fa} {input.assembly} \
            2> {log} | gzip -c > {output}
        """

# SAM mapping (for BAM + pileup)
rule map_sam:
    input:
        assembly = lambda wc: hap_fa[wc.hap],
        minimap2 = ROOT + "/minimap2",
        ref_fa   = REF_FA
    output:
        config["tool"] + "/{sample}.hap{hap}.sam.gz"
    log:
        config["tool"] + "/{sample}.hap{hap}.sam.gz.log"
    threads: 8
    resources:
        mem_mb = 16000,
        runtime = 2880
    params:
        mm2 = MM2_OPTS
    shell:
        """
        mkdir -p $(dirname {output})
        {input.minimap2} -a {params.mm2} -t {threads} {input.ref_fa} {input.assembly} \
            2> {log} | gzip -c > {output}
        """

######################################################################
# Step 2: Process PAF files to variant calls and BED regions
######################################################################

# Call variants from PAF with paftools (per haplotype)
rule hap_var:
    input:
        paf       = config["tool"] + "/{sample}.hap{hap}.paf.gz",
        k8        = ROOT + "/k8",
        paftools  = ROOT + "/paftools.js"
    output:
        var = config["tool"] + "/{sample}.hap{hap}.var.gz"
    log:
        config["tool"] + "/{sample}.hap{hap}.var.gz.vst"
    threads: 1
    resources:
        mem_mb = 8000,
        runtime = 180
    shell:
        """
        gzip -dc {input.paf} \
          | sort -k6,6 -k8,8n \
          | {input.k8} {input.paftools} call - 2> {log} \
          | gzip -c > {output.var}
        """

# Extract R lines to BED (per haplotype)
rule hap_bed:
    input:
        config["tool"] + "/{sample}.hap{hap}.var.gz"
    output:
        config["tool"] + "/{sample}.hap{hap}.bed"
    threads: 1
    resources:
        mem_mb = 4000,
        runtime = 30
    shell:
        """
        gzip -dc {input} | grep '^R' | cut -f2- > {output}
        """

######################################################################
# Step 3: Process SAM files to BAM and variant calls
######################################################################

# Filter SAM and sort to BAM
rule sam_to_bam:
    input:
        sam        = config["tool"] + "/{sample}.hap{hap}.sam.gz",
        k8         = ROOT + "/k8",
        dipcall_aux = ROOT + "/dipcall-aux.js",
        samtools   = ROOT + "/samtools"
    output:
        bam = config["tool"] + "/{sample}.hap{hap}.bam"
    log:
        config["tool"] + "/{sample}.hap{hap}.bam.log"
    threads: 4
    resources:
        mem_mb = 20000,
        runtime = 360
    shell:
        """
        {input.k8} {input.dipcall_aux} samflt {input.sam} 2> {log} \
            | {input.samtools} sort -m4G --threads 4 -o {output.bam} -
        """

# Joint pileup to pair VCF (hap1 + hap2 as two samples)
rule pair_vcf:
    input:
        hap1   = config["tool"] + f"/{SAMPLE}.hap1.bam",
        hap2   = config["tool"] + f"/{SAMPLE}.hap2.bam",
        htsbox = ROOT + "/htsbox",
        ref_fa = REF_FA
    output:
        config["tool"] + f"/{SAMPLE}.pair.vcf.gz"
    log:
        config["tool"] + f"/{SAMPLE}.pair.vcf.gz.log"
    threads: 2
    resources:
        mem_mb = 16000,
        runtime = 480
    shell:
        """
        {input.htsbox} pileup -q5 -evcf {input.ref_fa} {input.hap1} {input.hap2} 2> {log} \
            | {input.htsbox} bgzip > {output}
        """


######################################################################
# Step 4: Generate final outputs
######################################################################

# Convert pair VCF to diploid VCF (handle PAR properly)
rule dip_vcf:
    input:
        vcf         = config["tool"] + f"/{SAMPLE}.pair.vcf.gz",
        k8          = ROOT + "/k8",
        dipcall_aux = ROOT + "/dipcall-aux.js",
        htsbox      = ROOT + "/htsbox",
        par_bed     = PAR_BED
    output:
        config["tool"] + f"/{SAMPLE}.dip.vcf.gz"
    log:
        config["tool"] + f"/{SAMPLE}.dip.vcf.gz.log"
    threads: 1
    resources:
        mem_mb = 8000,
        runtime = 120
    shell:
        """
        {input.k8} {input.dipcall_aux} vcfpair -p {input.par_bed} {input.vcf} 2> {log} \
            | {input.htsbox} bgzip > {output}
        """

# Combine hap1/hap2 BEDs into dipcall-style diploid callable BED
rule dip_bed:
    input:
        hap1_bed = config["tool"] + f"/{SAMPLE}.hap1.bed",
        hap2_bed = config["tool"] + f"/{SAMPLE}.hap2.bed",
        bedtk    = ROOT + "/bedtk",
        par_bed  = PAR_BED
    output:
        config["tool"] + f"/{SAMPLE}.dip.bed"
    log:
        config["tool"] + f"/{SAMPLE}.dip.bed.log"
    threads: 1
    resources:
        mem_mb = 8000,
        runtime = 60
    params:
        tmp = config["tool"] + f"/{SAMPLE}.tmp.bed"
    shell:
        """
        set -euo pipefail

        # Autosomes: intersection of both haps, excluding X/Y
        {input.bedtk} isec {input.hap1_bed} {input.hap2_bed} \
            | egrep -v '^(chr)?[XY]' > {params.tmp}

        # PAR: intersection of both haps, intersected with PAR bed
        {input.bedtk} isec {input.hap1_bed} {input.hap2_bed} \
            | {input.bedtk} isec {input.par_bed} >> {params.tmp}

        # Non-PAR X: hap2 minus hap1, minus PAR
        {input.bedtk} sub {input.hap2_bed} {input.hap1_bed} \
            | egrep '^(chr)?X' \
            | {input.bedtk} sub - {input.par_bed} >> {params.tmp}

        # Y: hap1 minus hap2
        {input.bedtk} sub {input.hap1_bed} {input.hap2_bed} \
            | egrep '^(chr)?Y' >> {params.tmp}

        {input.bedtk} sort {params.tmp} > {output}
        """