"""
YAHS
font is small here: https://patorjk.com/software/taag
"""

from Bio import SeqIO
import gzip
import os
import sys
minchromsize = 1000000
configfile: "config.yaml"
config["tool"] = "GAP_yahs"


qvals = [5]

for x in config["assemblies"]:
    if "_" in x:
        raise IOError("You must not have any special characters in the assembly names: {}. Just use [A-Za-z0-9]+".format(x))

filepath = os.path.dirname(os.path.realpath(workflow.snakefile))
chromappath = os.path.join(filepath, "../bin/chromap/chromap")

def flatten(list_of_lists):
    if len(list_of_lists) == 0:
        return list_of_lists
    if isinstance(list_of_lists[0], list):
        return flatten(list_of_lists[0]) + flatten(list_of_lists[1:])
    return list_of_lists[:1] + flatten(list_of_lists[1:])

wildcard_constraints:
    datatype="[A-Za-z0-9]+",
    kmer="[A-Za-z0-9]+",
    nom="[A-Za-z0-9.]+",
    telo="[A-Za-z0-9]+",
    binsize="[0-9]+",
    qval="[0-9]+",
    telodir="[fr]"

rule all:
    input:
        expand(config["tool"] + "/output/{nom}/{nom}_q_{qval}.bed",
                nom = config["assemblies"], qval = qvals),
        expand(config["tool"] + "/output/{nom}/{nom}_hic.sorted.bam",
                nom = config["assemblies"]),
        expand(config["tool"] + "/output/{nom}/yahs/{nom}_scaffolds_final.fa",
                nom = config["assemblies"])

 
# make softlinks of the input files
# files end up here:
#   assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
filepath = os.path.dirname(os.path.realpath(workflow.snakefile))
softlinks_rule_path=os.path.join(filepath, "snakemake_includes/assembly_softlinks")
include: softlinks_rule_path

rule chrom_size:
    """
    make a file with the chromosome sizes
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta"
    output:
        cs = config["tool"] + "/output/{nom}/{nom}_chromsize.txt"
    threads: 1
    shell:
        """
        bioawk -cfastx '{{printf("%s\\t%d\\n", $name, length($seq))}}' {input.assem} > {output.cs}
        """

#      _ ___   _ _____     _    _       __ _ _
#   _ | | _ ) /_\_   _|   | |_ (_)__   / _(_) |___ ___
#  | || | _ \/ _ \| |    _| ' \| / _| |  _| | / -_|_-<
#   \__/|___/_/ \_\_|   (_)_||_|_\__| |_| |_|_\___/__/
#
rule compile_chromap:
    """
    compile chromap if it does not yet exist
    """
    output:
        chromap = os.path.join(filepath, "../bin/chromap/chromap")
    params:
        mvdir = os.path.join(filepath, "../bin/")
    threads: 1
    shell:
        """
        git clone https://github.com/haowenz/chromap.git
        cd chromap
        make
        cd ..
        mv chromap/ {params.mvdir}
        """

rule check_assembly:
    """
    Check that there are no duplicate seqnames in the assembly.
    This will fail silently in JBAT and waste time.
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta"
    output:
        check = config["tool"] + "/input/assembly/{nom}_input.fasta.check"
    threads: 1
    run:
        chromlist = set()
        with open(input.assem) as handle:
            for record in SeqIO.parse(handle, "fasta"):
                if record.id in chromlist:
                    raise IOError("There are some sequence IDs that are duplicated in the fasta file. Please make sure that each file has a unique ID and restart the pipeline")
                chromlist.add(record.id)
        with open(output.check, "w") as outhandle:
            print("fasta headers are all unique", file = outhandle)

rule index_ref:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        check = config["tool"] + "/input/assembly/{nom}_input.fasta.check",
        chromap = os.path.join(filepath, "../bin/chromap/chromap")
    output:
        index = config["tool"] + "/input/assembly/{nom}_input.fasta.index"
    shell:
        """
        {input.chromap} -i -r {input.assem} -o {output.index}
        """

rule generate_assembly_for_hic_gen:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        check = config["tool"] + "/input/assembly/{nom}_input.fasta.check",
        awkscript= os.path.abspath(os.path.join( filepath, "../bin/generate-assembly-file-from-fasta.awk"))
    output:
        assembly = config["tool"] + "/input/assembly/{nom}_input.fasta.assembly"
    threads: 1
    shell:
        """
        awk -f {input.awkscript} {input.assem} > {output.assembly}
        """

rule editable_assembly_file:
    """
    from https://bitbucket.org/bredeson/artisanal/src/master/
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        check = config["tool"] + "/input/assembly/{nom}_input.fasta.check",
        assemfromfasta= os.path.abspath(os.path.join( filepath, "../bin/assembly-from-fasta.py"))
    output:
        assembly = config["tool"] + "/output/{nom}/{nom}.assembly"
    params:
        outprefix = lambda wildcards: config["tool"] + "/output/{d}/{d}".format(
                     d=wildcards.nom)
    threads: 1
    shell:
        """
        python {input.assemfromfasta} -c {input.assem} {params.outprefix}
        """

rule hic_to_pairs:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        check = config["tool"] + "/input/assembly/{nom}_input.fasta.check",
        index   = config["tool"] + "/input/assembly/{nom}_input.fasta.index",
        chromap = chromappath,
        left  = flatten([config["libs"][x]["read1"] for x in config["libs"]]),
        right = flatten([config["libs"][x]["read2"] for x in config["libs"]])
    output:
        pairs = config["tool"] + "/output/{nom}/{nom}_q_{qval}.pairs"
    params:
        left  = " -1 ".join(flatten([config["libs"][x]["read1"] for x in config["libs"]])),
        right = " -2 ".join(flatten([config["libs"][x]["read2"] for x in config["libs"]])),
        qval  = lambda wildcards: wildcards.qval
    threads: workflow.cores - 2
    shell:
        """
        {input.chromap} --preset hic -x {input.index} \
            -r {input.assem} \
            -1 {params.left}  \
            -2 {params.right} \
            -t {threads} \
            -q {params.qval} \
            -o {output.pairs}
        """

rule hic_to_sam:
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        check = config["tool"] + "/input/assembly/{nom}_input.fasta.check",
        index   = config["tool"] + "/input/assembly/{nom}_input.fasta.index",
        chromap = chromappath,
        left  = flatten([config["libs"][x]["read1"] for x in config["libs"]]),
        right = flatten([config["libs"][x]["read2"] for x in config["libs"]])
    output:
        sam = temp(config["tool"] + "/output/{nom}/{nom}_hic.sam")
    params:
        left  = ",".join(flatten([config["libs"][x]["read1"] for x in config["libs"]])),
        right = ",".join(flatten([config["libs"][x]["read2"] for x in config["libs"]]))
    threads: workflow.cores - 2
    shell:
        """
        {input.chromap} --preset hic -x {input.index} \
            -r {input.assem} \
            -1 {params.left}  \
            -2 {params.right} \
            -t {threads} \
            --SAM \
            -o {output.sam}
        """

rule hic_to_bam:
    """
    Now convert the sam to bam and sort
    """
    input:
        sam = config["tool"] + "/output/{nom}/{nom}_hic.sam"
    output:
        bam = config["tool"] + "/output/{nom}/{nom}_hic.sorted.bam"
    threads: max(1, int(workflow.cores / 2))
    shell:
        """
        samtools view -@ {threads} -hb {input.sam} | \
            samtools sort -@ {threads} -o {output.bam}
        """

rule pairs_to_bed:
    """
    Converts the pairs file to a bed file used for yahs.
    The input and output are both tab-delimited.

    The input file looks like this:
    TUPAC_0001:3:1:0:1452#0  chr7  118970079  chr7  118965072  +  +  UU

    The output file looks like this:
    chr7   118970079   118970129   TUPAC_0001:3:1:0:1452#0/1   37   -
    chr7   118965072   118965122   TUPAC_0001:3:1:0:1452#0/2   37   +
    """
    input:
        pairs = config["tool"] + "/output/{nom}/{nom}_q_{qval}.pairs"
    output:
        bedfile = config["tool"] + "/output/{nom}/{nom}_q_{qval}.bed"
    threads: 1
    shell:
        """
        cat {input.pairs} | \
        grep -v '#' | \
        awk 'BEGIN{{OFS="\t"}}{{ \
             print $2,$3,$3+50,$1"/1",37,$6; \
             print $4,$5,$5+50,$1"/2",37,$7}}' > {output.bedfile}
        """

rule index_assembly:
    """
    Run samtools faidx on the assembly to generate a .fai
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        check = config["tool"] + "/input/assembly/{nom}_input.fasta.check"
    output:
        fai = config["tool"] + "/input/assembly/{nom}_input.fasta.fai"
    shell:
        """
        samtools faidx {input.assem}
        """

rule run_yahs_on_the_data:
    """
    needs a more recent version of yahs
    """
    input:
        assem = config["tool"] + "/input/assembly/{nom}_input.fasta",
        fai = config["tool"] + "/input/assembly/{nom}_input.fasta.fai",
        bam = config["tool"] + "/output/{nom}/{nom}_hic.sorted.bam"
    output:
        yahs = config["tool"] + "/output/{nom}/yahs/{nom}_scaffolds_final.fa",
        agp  = config["tool"] + "/output/{nom}/yahs/{nom}_scaffolds_final.agp",
        yahsbin  = temp(config["tool"] + "/output/{nom}/yahs/{nom}.bin"),
    params:
        outprefix = config["tool"] + "/output/{nom}/yahs/{nom}"
    threads: workflow.cores - 1
    shell:
        """
        yahs -o {params.outprefix} --no-contig-ec --no-scaffold-ec --no-mem-check \
            {input.assem} {input.bam}
        """





